######################################################################
######################### TPPA PSEUDO CODE ###########################
######################################################################

################################ MAIN ################################
init_pp = (v_start, v_start)
init_ppa_instance = get_ppa_instance(ppa_inst_set, init_pp)
insert init_pp tp init_ppa_instance

while (ppa_inst_set is not empty):
	pp , ppa_instance = pop from ppa_inst_set
	if pp is dominated in ppa_instance:
		continue

	if pp.vertex == v_goal:
		merge pp to solution in ppa_instance
		continue

	for all edges out of pp.vertex:
		new_pp = = extend(pp, edge)

		if new_pp is dominated in ppa_instance: // IS THIS NEEDED?
			continue 

		if (new_tl, new_br) should not be split for eps3, ppa_inst_set: // KEEP PP CONNECTED
			new_ppa_instace = get_ppa_instance(ppa_inst_set, new_pp)

			if new_pp is not dominated in new_ppa_instance:
				insert new_pp to new_ppa_instance
		
		else: // SPLIT PP
			pp_tl = (new_pp.tl, new_pp.tl)
			pp_br = (new_pp.br, new_pp.br)

			tl_ppa_instance = get_ppa_instance(ppa_inst_set, pp_tl)
			br_ppa_instance = get_ppa_instance(ppa_inst_set, pp_br)

			if pp_tl is not dominated in tl_ppa_instace:
				insert pp_tl to tl_ppa_instance
			if pp_br is not dominated in br_ppa_instace:
				insert pp_br to br_ppa_instance

for ppa_instance in ppa_inst_set:
	for pp in ppa_instance.solutions:
		solutions.add(pp.tl)

return solutions

################################ POP ################################
ppa_instance_to_pop = null
for ppa_instance in ppa_inst_set:
	if ppa_instance.peek() < ppa_instance_to_pop.peek():
		ppa_instance_to_pop = ppa_instance

return ppa_instance_to_pop.pop()

########################## IS_SPLIT_NEEDED ###########################
pp_c3_min = min(pp.tl.c3, pp.br.c3)
pp_c3_max = max(pp.tl.c3, pp.br.c3)

if pp_c3_min * (1 + eps3) <= pp_c3_max:
	// CASE 0: Split if not bounded
	// [     - eps3 -      ]
	return true

for ppa_instance in ppa_inst_set:
	next_ppa_instance == next(ppa_instance)
	if (next_ppa_instance == null):
		next_ppa_instance.c3_min = inf


	if (ppa_instance.c3_min <= pp_c3_min <= ppa_instance.c3_max): // CASES 1-4
		if (ppa_instance.c3_min <= pp_c3_max <= ppa_instance.c3_max):
			// CASE 1: Don't split
			//     [   ]
			// [          ]
			return false

		else if (pp_c3_max < next_ppa_instance.c3_min):
			// CASE 4: Split if can't extend ppa_instance
			//     [    ]
			// [      ]    [  ]
			return !can_extend_ppa_instance(ppa_instance, pp_c3_min, pp_c3_max, eps3)

		else: // (next_ppa_instance.c3_min <= pp_c3_max)
			// CASE 2+3: Split
			//      [    ]        //    [           ]
			// [      ][    ]     // [    ][]...[][    ]
			return true

	else if: (ppa_instance.c3_max <= pp_c3_min <= next_ppa_instance.c3_min): CASES 5-7
		if (pp_c3_max < next_ppa_instance.c3_min):
			// CASE 5: Don't split
			//        [    ]
			// [    ]       [    ]
			return false

		else if (next_ppa_instance.c3_min <= pp_c3_max <= next_ppa_instance.c3_max):
			// CASE 6: Split if can't extend next_ppa_instance
			//        [     ]
			// [    ]     [    ]
			return !can_extend_ppa_instance(next_ppa_instance, pp_c3_min, pp_c3_max, eps3)

		else: // (next_ppa_instance.c3_max < pp_c3_max)
			// CASE 7: Split
			//        [         ]
			// [    ]   []..[][    ]
			return true


	// CASE 8: Don't split
	//        [    ]
	//
	return false

########################## GET_PPA_INSTANCE ##########################
// Should be called only on pp that should not be split

for ppa_instance in ppa_inst_set:
	if ppa_instance.c3_min <= pp.tl.c3 <= ppa_instance.c3_max:
		return ppa_instance

// We create ppa_instance automatically because pp can not be dominated by empty
// ppa_instance - hence pp will be inserted into it. Maybe split get_ppa_instance
// and add_ppa_instance into 2 units
new_ppa_instance = {
	.cost3_min=min(pp.tl.c3, pp.br,c3)
	.cost3_max=max(pp.tl.c3, pp.br,c3)
	.open_queue = empty()
	.solutions = empty()
	.g2_min = empty()
}
ppa_inst_set.add(new_ppa_instance)
return new_ppa_instance

##################### IS_DOMINATED (SAME AS PPA) #####################
g2_min = ppa_instance.g2_min
if (pp.br.cost2 >= g2_min(pp.vertex)): // DOMINATED BY EXISTING PATH 
	return true
else if ((pp.br.cost2 + h2(pp.vertex)) >= g2_min(goal)): // DOMINATED BY SOLUTION
	return true
else:
	return false

######################## EXTEND (SAME AS PPA) ########################
new_tl = pp.tl.extend(edge)
new_br = pp.br.extend(edge)
return (new_tl, new_br)

######################## INSERT (SAME AS PPA) ########################
for c_pp in ppa_instance.open_queue:
	merged_pp = merge(c_pp, pp)
	if merged_pp is bounded(eps1, eps2):
		open_queue.remove(c_pp)
		open_queue.insert(merged_pp)
		return
open_queue.insert(pp)

################## MERGE_TO_SOLUTIONS (SAME AS PPA) ##################
for c_pp in ppa_instance.solutions:
	merged_pp = merge(c_pp, pp)
	if merged_pp is bounded(eps1, eps2):
		open_queue.remove(c_pp)
		open_queue.insert(merged_pp)
		return
open_queue.insert(pp)
